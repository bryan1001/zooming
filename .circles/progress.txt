## Codebase Patterns
- Canvas element is in index.html with id="canvas"
- Three.js scene, camera, and renderer are initialized in src/main.ts
- Styles go in src/style.css with fullscreen canvas setup
- Use MeshStandardMaterial for objects that need lighting
- City-related modules go in src/city/ directory
- Use seeded random (mulberry32) for reproducible procedural generation
- Run `npm run typecheck` to verify TypeScript passes
- CHUNK_SIZE is 200 units (exported from chunk.ts), use for chunk management calculations
- ChunkManager handles dynamic chunk loading/unloading based on camera position
- Use deltaTime pattern: const delta = (performance.now() - lastTime) / 1000 for frame-rate independent updates
- Dispose geometry/materials when removing objects: mesh.geometry.dispose(); mesh.material.dispose()
- Scene-wide modules (lighting, etc.) go in src/ root, component-specific modules in subdirectories
- setupLighting(scene) in src/lighting.ts handles all scene lighting configuration
- Camera-related modules go in src/camera/ directory
- FlightPath class generates CatmullRomCurve3 through streets, extends dynamically as camera moves
- BLOCK_SIZE is 25 units (from chunk.ts), streets run at multiples of BLOCK_SIZE
- FLIGHT_HEIGHT is 30 units (consistent with camera y position)
- CameraController manages camera movement along FlightPath, use cameraController.update(deltaTime) each frame
- Audio modules go in src/audio/ directory
- AudioContext must be created after user interaction (browser autoplay policy)
- Use click-to-start overlay pattern: show overlay, wait for click, init audio, hide overlay, start experience
- getSourceNode() from audioPlayer.ts returns AudioBufferSourceNode for connecting to AnalyserNode
- Audio analyser is auto-initialized by loadAudio() and connects source->analyser->destination
- Use getFrequencyData() for Uint8Array of frequency bins, getAverageFrequency() for quick energy reading
- getFrequencyRangeAverage(startBin, endBin) isolates frequency bands (e.g., bass 0-10, mids 10-100)
- FFT_SIZE is 2048, frequencyBinCount is 1024 (bins cover 0 to Nyquist frequency)
- For beat-synced effects, use onBeat(callback) and scale effect by intensity (0-1)
- Frame-rate independent smooth transitions: use exponential decay (1 - e^(-k*deltaTime)), k=15 for ~200ms
- Effects modules go in src/effects/ directory
- Use CSS vignette overlay (radial-gradient) for screen darkening effects, pointer-events: none to not block clicks
- initBeatEffects(camera) in src/effects/beatEffects.ts, then call triggerBeatPulse(intensity) on beat and updateBeatEffects(deltaTime) each frame
- For multi-material meshes (e.g., different textures per face), use array of materials: new THREE.Mesh(geometry, materials[])
- BoxGeometry face order: +X (right), -X (left), +Y (top), -Y (bottom), +Z (front), -Z (back)
- createWindowTextures(seed, litProbability, pattern) in src/city/windowTexture.ts returns colorTexture and emissiveTexture
- WINDOW_PATTERNS array has 4 patterns: 'grid', 'staggered', 'vertical-strips', 'sparse-random'
- Use (gridX + gridZ * 2) % 4 to ensure adjacent buildings have different window patterns
- onTransition(callback) in beatDetector.ts for major musical transitions (drops/breakdowns), debounced to 8 seconds
- BulletAvatar class in src/camera/bulletAvatar.ts for third-person view, takes (scene, flightPath) constructor args
- Use CapsuleGeometry for elongated glowing objects, rotateX(Math.PI/2) to align with Z-axis
- Post-processing: import from 'three/examples/jsm/postprocessing/', use EffectComposer with RenderPass + effect passes
- initMotionBlur(renderer, scene, camera) returns composer, use renderWithMotionBlur() instead of renderer.render()
- Call resizeMotionBlur(width, height, pixelRatio) on window resize to update composer size
- Performance modules go in src/performance/ directory
- Use stats.js for FPS monitoring: initStats(), statsBegin(), statsEnd()
- InstancedMesh is more efficient than individual meshes: use for buildings in chunks
- Disable WebGL antialias (false) and use FXAA post-processing pass instead for better performance
- Limit pixel ratio to 1.5 for better performance on high-DPI displays
- For InstancedMesh, dispose() only clears instance data; shared geometry/materials persist
- onHeavyBeatShift(callback) in beatDetector.ts for musically significant moments (2.5x energy spike after silence), debounced to 2 seconds
- TurnController in src/camera/turnController.ts handles 90-degree turn animations with executeTurn(direction)
- FlightPath now uses distance-based tracking (getPositionAtDistance, extendIfNeededByDistance) for direction-agnostic movement
- CameraController tracks currentDistance for path traversal, integrates TurnController for turns
- Turn animation duration is 175ms (TURN_DURATION constant) with ease-in-out cubic easing

- canTurnSafely(direction) in TurnController checks for obstacles before turning using grid-based collision detection
- Buildings are at block centers: (n * BLOCK_SIZE + BLOCK_SIZE/2, *, m * BLOCK_SIZE + BLOCK_SIZE/2)
- Streets run at multiples of BLOCK_SIZE
- Use setPositionProvider() on TurnController to enable obstacle detection
- getBankAngle() in TurnController returns current camera roll for banking effect (50 degrees max)
- Banking has 3 phases: anticipation (50ms before turn), turning (full bank), follow-through (100ms after)

---

## 2026-02-02 - US-001
- Implemented heavy beat shift detection in beatDetector.ts
- Added `detectHeavyBeatShift()` function that detects energy spikes > 2.5x rolling average
- Requires silence/low energy (< 0.5x rolling average) in the 200ms before the spike
- Added `onHeavyBeatShift(callback)` and `offHeavyBeatShift(callback)` subscription functions
- Added 2-second debounce (MIN_HEAVY_BEAT_INTERVAL_MS = 2000)
- Files changed: src/audio/beatDetector.ts
- **Learnings for future iterations:**
  - Beat detection already has a modular callback subscription pattern (onBeat, onTransition), follow same pattern
  - Heavy beat shifts need both conditions: high energy spike AND pre-silence period
  - Use frame-based history checks (12 frames ≈ 200ms at 60fps) for pre-silence detection
---

## 2026-02-02 - US-002
- Created TurnController module in src/camera/turnController.ts
- Implements `executeTurn(direction: 'left' | 'right')` that rotates flight direction by exactly 90 degrees
- Turn animation completes in 175ms (within 150-200ms range) using ease-in-out cubic easing
- After turn completes, calls `flightPath.setFlightDirection(angle)` to regenerate path in new direction
- Updated FlightPath to use distance-based tracking instead of Z-based for direction-agnostic movement
- Added `getPositionAtDistance()`, `getTangentAtDistance()`, `extendIfNeededByDistance()` methods
- CameraController now tracks `currentDistance` and applies turn animation to camera look direction
- Added keyboard controls (ArrowLeft/ArrowRight or A/D) in main.ts for testing turns
- Files changed: src/camera/turnController.ts (new), src/camera/flightPath.ts, src/camera/cameraController.ts, src/main.ts
- **Learnings for future iterations:**
  - Z-based path tracking breaks after 90-degree turns (Z stops changing when flying along X axis)
  - Use distance-based tracking (distanceToT) for direction-agnostic path traversal
  - CatmullRomCurve3.getPointAt(t) gives smooth interpolation along spline curves
  - Turn animations should modify the tangent/look direction during the turn, then path regenerates after
---

## 2026-02-02 - US-003
- Added `canTurnSafely(direction)` method to TurnController in src/camera/turnController.ts
- Uses grid-based collision detection instead of raycasting (more efficient for InstancedMesh buildings)
- Checks 100 units in turn direction using `checkPathClear()` method
- Also checks 200 units ahead from the post-turn position
- Returns true only if both checks pass
- CameraController exposes `canTurnSafely(direction)` for external use
- Added `setPositionProvider()` to TurnController for obstacle detection to know current position
- Files changed: src/camera/turnController.ts, src/camera/cameraController.ts
- **Learnings for future iterations:**
  - Grid-based collision detection is more efficient than raycasting for InstancedMesh buildings
  - Building centers are at (n * BLOCK_SIZE + BLOCK_SIZE/2) in both X and Z
  - Use a position provider pattern to decouple position tracking from obstacle detection
  - Check at intervals of BLOCK_SIZE/2 along paths for reliable collision detection
---

## 2026-02-02 - US-004
- Connected heavy beat shifts to turn execution in src/main.ts
- Subscribed to `onHeavyBeatShift()` callback to trigger turns on musically significant moments
- Turn direction selection logic:
  - If both directions are safe, alternate (using `lastTurnDirection` state variable)
  - If only one direction is safe, turn that way
  - If neither direction is safe, skip the turn (maintain straight flight)
- Files changed: src/main.ts
- **Learnings for future iterations:**
  - Track last turn direction as module-level state for alternation logic
  - `executeTurn()` returns boolean indicating if turn started (useful for updating state)
  - Heavy beat shifts are already debounced (2 seconds), no additional debouncing needed
---

## 2026-02-02 - US-005
- Added dramatic banking animation to turns in TurnController
- Banking state machine with 3 phases: anticipation (50ms), turning, follow-through (100ms)
- Bank angle reaches 50 degrees (BANK_ANGLE_DEGREES constant)
- Added `getBankAngle()` method to TurnController that returns current roll in radians
- CameraController applies banking via `camera.rotateZ(bankAngle)` after lookAt
- Uses ease-in-out cubic easing for smooth banking transitions
- Files changed: src/camera/turnController.ts, src/camera/cameraController.ts
- **Learnings for future iterations:**
  - Use a state machine for multi-phase animations (anticipation → action → follow-through)
  - Apply rotateZ after lookAt to avoid coordinate conflicts
  - Bank into the turn direction (left turn = negative roll, right turn = positive roll)
  - Animation is fast (~275ms total), so visual verification requires multiple screenshot attempts or GIF recording
---

## 2026-02-02 - US-006
- Added 4 distinct window patterns to windowTexture.ts: grid, staggered, vertical-strips, sparse-random
- Created `shouldHaveWindow()` function that determines window placement based on pattern type
- Grid: regular windows at every position
- Staggered: offset odd rows, creates brick-like arrangement
- Vertical-strips: windows only in columns 0-1 and 4-5 (skip 2-3 and 6-7)
- Sparse-random: 40% random window placement
- Updated `createWindowTextures()` to accept optional pattern parameter
- Updated texture cache to key by both seed and pattern
- Updated instancedBuildings.ts to create 4 material variants (one per pattern)
- Buildings select pattern based on grid position: `(gridX + gridZ * 2) % 4`
- This ensures horizontally/vertically adjacent buildings always have different patterns
- Files changed: src/city/windowTexture.ts, src/city/instancedBuildings.ts
- **Learnings for future iterations:**
  - Use grid position for pattern selection, not random seed, to guarantee adjacency difference
  - With 4 patterns, using `(gridX + gridZ * 2) % 4` creates a varied pattern where neighbors always differ
  - Cache keys must include all parameters that affect texture output (seed + pattern)
  - Use type-only imports for TypeScript types when verbatimModuleSyntax is enabled
---

