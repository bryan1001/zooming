## Codebase Patterns
- Canvas element is in index.html with id="canvas"
- Three.js scene, camera, and renderer are initialized in src/main.ts
- Styles go in src/style.css with fullscreen canvas setup
- Use MeshStandardMaterial for objects that need lighting
- City-related modules go in src/city/ directory
- Use seeded random (mulberry32) for reproducible procedural generation
- Run `npm run typecheck` to verify TypeScript passes
- CHUNK_SIZE is 200 units (exported from chunk.ts), use for chunk management calculations
- ChunkManager handles dynamic chunk loading/unloading based on camera position
- Use deltaTime pattern: const delta = (performance.now() - lastTime) / 1000 for frame-rate independent updates
- Dispose geometry/materials when removing objects: mesh.geometry.dispose(); mesh.material.dispose()
- Scene-wide modules (lighting, etc.) go in src/ root, component-specific modules in subdirectories
- setupLighting(scene) in src/lighting.ts handles all scene lighting configuration
- Camera-related modules go in src/camera/ directory
- FlightPath class generates CatmullRomCurve3 through streets, extends dynamically as camera moves
- BLOCK_SIZE is 25 units (from chunk.ts), streets run at multiples of BLOCK_SIZE
- FLIGHT_HEIGHT is 30 units (consistent with camera y position)
- CameraController manages camera movement along FlightPath, use cameraController.update(deltaTime) each frame
- Audio modules go in src/audio/ directory
- AudioContext must be created after user interaction (browser autoplay policy)
- Use click-to-start overlay pattern: show overlay, wait for click, init audio, hide overlay, start experience
- getSourceNode() from audioPlayer.ts returns AudioBufferSourceNode for connecting to AnalyserNode
- Audio analyser is auto-initialized by loadAudio() and connects source->analyser->destination
- Use getFrequencyData() for Uint8Array of frequency bins, getAverageFrequency() for quick energy reading
- getFrequencyRangeAverage(startBin, endBin) isolates frequency bands (e.g., bass 0-10, mids 10-100)
- FFT_SIZE is 2048, frequencyBinCount is 1024 (bins cover 0 to Nyquist frequency)

---

## 2026-02-02 - US-001
- What was implemented:
  - Initialized Vite + TypeScript project
  - Installed Three.js and @types/three
  - Created index.html with canvas element
  - Created main.ts with basic Three.js scene (rotating cube, lighting)
  - Configured fullscreen canvas styling
- Files changed:
  - index.html (canvas element)
  - src/main.ts (Three.js scene setup)
  - src/style.css (fullscreen canvas styles)
  - package.json (added three, @types/three)
- **Learnings for future iterations:**
  - Vite uses vanilla-ts template for TypeScript projects
  - Three.js requires both three and @types/three packages
  - Canvas needs display:block to prevent scrollbars
  - MeshStandardMaterial requires lighting to be visible
  - Run `npm run typecheck` to verify TypeScript (script added to package.json)
---

## 2026-02-02 - US-002
- What was implemented:
  - Created src/city/building.ts module with createBuilding function
  - Buildings use seeded random number generator for reproducible randomness
  - Building dimensions: height 10-100 units, width/depth 5-20 units
  - Buildings positioned with base at y=0
  - Added typecheck script to package.json
- Files changed:
  - src/city/building.ts (new file - building generator)
  - package.json (added typecheck script)
- **Learnings for future iterations:**
  - Use seeded random (mulberry32) for reproducible procedural generation
  - Position meshes by setting y to half the height for floor-aligned objects
  - City-related modules go in src/city/ directory
---

## 2026-02-02 - US-003
- What was implemented:
  - Created src/city/chunk.ts module with createChunk function
  - Chunk is a 200x200 unit area (CHUNK_SIZE constant exported)
  - Buildings placed in a grid pattern with 25-unit blocks (provides street gaps)
  - Uses hashPosition() for reproducible building seeds based on world coordinates
  - Chunk stores its coordinates in userData for identification
- Files changed:
  - src/city/chunk.ts (new file - chunk generator)
- **Learnings for future iterations:**
  - CHUNK_SIZE is 200 units, exported for use by other modules
  - Block size of 25 units provides room for buildings (5-20 units) plus street gaps
  - Use hashPosition() pattern to generate unique seeds from world coordinates
  - Store chunk identification in Group.userData for later management
  - Grid layout: blocksPerSide = floor(CHUNK_SIZE / BLOCK_SIZE) = 8 buildings per axis
---

## 2026-02-02 - US-004
- What was implemented:
  - Created src/city/chunkManager.ts module with ChunkManager class
  - Tracks loaded chunks in a Map using "chunkX,chunkZ" keys
  - Generates chunks 3 ahead of camera and keeps 2 behind in Z direction
  - Loads chunks laterally (2 on each side) for visibility
  - Removes chunks beyond view and disposes of geometry/materials to free memory
  - Updated main.ts to use ChunkManager and enable camera movement
  - Camera positioned at street level (y=30) moving forward at 50 units/sec
  - Increased far plane to 2000 for distant chunk visibility
- Files changed:
  - src/city/chunkManager.ts (new file - chunk loading/unloading manager)
  - src/main.ts (integrated ChunkManager, removed demo cube, added camera movement)
- **Learnings for future iterations:**
  - Use Map with string keys for chunk tracking (e.g., "chunkX,chunkZ")
  - worldToChunk: Math.floor(worldPos / CHUNK_SIZE) converts world to chunk coords
  - Dispose geometry and materials when removing chunks to prevent memory leaks
  - Use performance.now() and deltaTime for frame-rate independent movement
  - Camera far plane needs to be large enough to see distant chunks (2000+ units)
  - Camera y=30 provides good street-level view of buildings
---

## 2026-02-02 - US-005
- What was implemented:
  - Created src/lighting.ts module with setupLighting function
  - Dark blue/purple background (0x0a0a1a) for night sky
  - Fog matching background color (100 to 800 units) for depth and atmosphere
  - Ambient light (dim blue 0x2a2a4a, intensity 0.5)
  - Directional moonlight (0x6a6a8a, intensity 0.8) from above
  - Hemisphere light for natural ambient gradient (sky/ground colors)
  - Updated main.ts to use new lighting module instead of inline lights
- Files changed:
  - src/lighting.ts (new file - atmospheric lighting setup)
  - src/main.ts (replaced inline lighting with setupLighting call)
- **Learnings for future iterations:**
  - Lighting modules go in src/ root (not src/city/) since they're scene-wide
  - Use fog to hide chunk loading and create depth perception
  - Fog start/end values (100, 800) work well with CHUNK_SIZE of 200
  - Hemisphere light adds natural ambient variation (brighter sky, darker ground)
  - Blue/purple tones (0x2a2a4a) create night atmosphere without being too dark
---

## 2026-02-02 - US-006
- What was implemented:
  - Created src/camera/flightPath.ts module with FlightPath class
  - Uses CatmullRomCurve3 for smooth path through the city
  - Path points placed at street level (y=30), along street grid lines (multiples of BLOCK_SIZE)
  - Dynamically extends path ahead as camera approaches end (EXTEND_THRESHOLD = 500 units)
  - Exports getPositionAt(t), getTangentAt(t) for parametric access (0-1)
  - Also exports getPositionAtZ(z), getTangentAtZ(z) for Z-based access
  - Uses seeded random (mulberry32) for reproducible path variations
- Files changed:
  - src/camera/flightPath.ts (new file - spline-based flight path generator)
- **Learnings for future iterations:**
  - Camera modules go in src/camera/ directory
  - Streets run at (n * BLOCK_SIZE) positions, buildings at (n * BLOCK_SIZE + BLOCK_SIZE/2)
  - CatmullRomCurve3 provides getPointAt(t) and getTangentAt(t) for smooth interpolation
  - extendIfNeeded(cameraZ) should be called each frame to extend path ahead of camera
  - Path extends when within EXTEND_THRESHOLD (500 units) of the end
---

## 2026-02-02 - US-007
- What was implemented:
  - Created src/camera/cameraController.ts module with CameraController class
  - Camera follows FlightPath spline at configurable base speed (default 50 units/sec)
  - Camera looks in direction of travel using tangent from the path
  - Exports update(deltaTime) method for frame-rate independent movement
  - Exports setSpeed(speed), getSpeed(), boostSpeed(multiplier), easeToBaseSpeed(factor) methods for future beat sync
  - Updated main.ts to use CameraController instead of inline camera movement
- Files changed:
  - src/camera/cameraController.ts (new file - camera movement along flight path)
  - src/main.ts (integrated CameraController, removed inline camera movement)
- **Learnings for future iterations:**
  - CameraController wraps FlightPath and camera for unified movement control
  - Use boostSpeed(multiplier) and easeToBaseSpeed(factor) for beat-synced speed changes
  - Camera position and lookAt are updated via updateCameraPosition() internal method
  - getCurrentZ() returns the Z position for chunk manager coordination
  - All camera movement should go through CameraController.update(deltaTime)
---

## 2026-02-02 - US-008
- What was implemented:
  - Added stock synthwave MP3 to public/audio/synthwave.mp3 (royalty-free from Pixabay)
  - Created src/audio/audioPlayer.ts module with Web Audio API
  - AudioContext initialized on user click (browser autoplay policy compliance)
  - Exports initAudio(), loadAudio(), play(), stop(), getAudioContext(), getSourceNode()
  - Added click-to-start overlay to index.html with "Zooming" title
  - Styled overlay with purple glow effect and pulse animation in style.css
  - Main.ts now waits for click before starting camera movement
- Files changed:
  - public/audio/synthwave.mp3 (new file - royalty-free synthwave track)
  - src/audio/audioPlayer.ts (new file - Web Audio API player)
  - index.html (added start-overlay div)
  - src/style.css (added overlay styles)
  - src/main.ts (integrated audio player, click-to-start flow)
- **Learnings for future iterations:**
  - Audio modules go in src/audio/ directory
  - Browser autoplay policy requires AudioContext creation after user interaction
  - Use audioContext.state === 'suspended' check and resume() for policy compliance
  - getSourceNode() returns the AudioBufferSourceNode for connecting to AnalyserNode later
  - Start overlay pattern: show overlay, wait for click, init audio, hide overlay, start experience
  - Use CSS transition for smooth overlay fade-out (opacity 0.5s ease)
---

## 2026-02-02 - US-009
- What was implemented:
  - Created src/audio/audioAnalyser.ts module with Web Audio API AnalyserNode
  - AnalyserNode configured with FFT size 2048 (1024 frequency bins)
  - Exports getFrequencyData() returning Uint8Array of frequency values (0-255)
  - Exports getAverageFrequency() for quick overall energy reading
  - Exports getFrequencyRangeAverage(startBin, endBin) for band-specific analysis
  - Updated audioPlayer.ts to auto-initialize analyser and route audio through it
- Files changed:
  - src/audio/audioAnalyser.ts (new file - frequency analysis module)
  - src/audio/audioPlayer.ts (imports analyser, routes audio through it)
- **Learnings for future iterations:**
  - AnalyserNode.getByteFrequencyData() fills a Uint8Array with frequency values 0-255
  - Must use Uint8Array<ArrayBuffer> type for TypeScript compatibility with Web Audio API
  - Audio routing: sourceNode -> analyserNode -> audioContext.destination
  - smoothingTimeConstant (0.8) smooths frequency data over time for less jittery values
  - frequencyBinCount = fftSize / 2; each bin covers (sampleRate / fftSize) Hz
---
